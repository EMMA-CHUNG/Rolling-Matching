# -*- coding: utf-8 -*-
"""causal inference-rolling matching .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S4kne4Qokg9umEz04WtXGnOQ1AIxs4rS
"""

import numpy as np
import pandas as pd
from sklearn.neighbors import NearestNeighbors
import matplotlib.pyplot as plt
import seaborn as sns

# =============================================================================
# Data Simulation (same as provided)
# =============================================================================
# Set random seed for reproducibility
np.random.seed(42)

# Simulation parameters
N = 1000
MONTHS = 12
PROGRAMS = 3
program_effects = {'A': 0.12, 'B': 0.08, 'C': 0.15}

# Generate baseline characteristics
prior_physical = np.random.binomial(1, 0.4, size=N)
office_visits = np.clip(np.random.poisson(6, size=N), 0, 12)

# Initialize data structures
outreach_history = np.zeros((N, MONTHS, PROGRAMS))
completed = np.zeros(N, dtype=int)
completion_month = np.zeros(N, dtype=int)

# Outreach probability function
def outreach_probability(program, month, had_physical, office_visits, prev_outreach):
    base_probs = {0: 0.10, 1: 0.08, 2: 0.12}
    factors = {
        'month': 1.0 + 0.2 * np.sin((month - 2) * np.pi / 6),
        'physical': 0.8 if had_physical else 1.2,
        'visits': 1.3 - (0.05 * office_visits),
        'history': 0.7 if prev_outreach > 0 else 1.0
    }
    prob = base_probs[program] * np.prod(list(factors.values()))
    return np.clip(prob, 0.01, 0.30)

# Simulation loop
base_hazard = np.linspace(0.12, 0.04, MONTHS)
for month in range(MONTHS):
    active = (completed == 0)
    if not active.any(): continue

    # Simulate outreach
    for program in range(PROGRAMS):
        for i in range(N):
            if not active[i]: continue
            prev_outreach = np.sum(outreach_history[i, :month, program])
            prob = outreach_probability(program, month, prior_physical[i],
                                       office_visits[i], prev_outreach)
            if np.random.rand() < prob:
                outreach_history[i, month, program] = 1

    # Simulate completions
    for i in range(N):
        if not active[i]: continue
        prob = base_hazard[month]
        if prior_physical[i]: prob *= 1.3
        prob *= 0.7 + (0.05 * office_visits[i])
        for prog in range(PROGRAMS):
            if outreach_history[i, month, prog]:
                prob += program_effects[chr(65 + prog)]
        if np.random.rand() < np.clip(prob, 0, 0.95):
            completed[i] = 1
            completion_month[i] = month + 1

# Create datasets
member_data = pd.DataFrame({
    'member_id': range(N),
    'prior_physical': prior_physical,
    'office_visits': office_visits,
    'completed_checkup': completed,
    'completion_month': completion_month
})
member_data['A_outreach'] = outreach_history[:, :, 0].sum(axis=1) > 0
member_data['B_outreach'] = outreach_history[:, :, 1].sum(axis=1) > 0
member_data['C_outreach'] = outreach_history[:, :, 2].sum(axis=1) > 0

person_month_data = []
for i in range(N):
    last_month = MONTHS if completion_month[i] == 0 else completion_month[i]
    for m in range(1, last_month + 1):
        entry = {
            'member_id': i,
            'month': m,
            'prior_physical': prior_physical[i],
            'office_visits': office_visits[i],
            'completed': (completion_month[i] == m),
            'prev_A': outreach_history[i, :m-1, 0].sum() > 0,
            'prev_B': outreach_history[i, :m-1, 1].sum() > 0,
            'prev_C': outreach_history[i, :m-1, 2].sum() > 0,
            'A_this_month': outreach_history[i, m-1, 0],
            'B_this_month': outreach_history[i, m-1, 1],
            'C_this_month': outreach_history[i, m-1, 2]
        }
        person_month_data.append(entry)
person_month_df = pd.DataFrame(person_month_data)
print(person_month_df)
# =============================================================================
# Rolling Matching Analysis
# =============================================================================
def rolling_matching_analysis(monthly_df, program, n_matches=5):
    """
    Perform rolling matching analysis for a specific program

    Args:
        monthly_df: Person-month dataframe
        program: Program to analyze ('A', 'B', or 'C')
        n_matches: Number of matches for each treated observation

    Returns:
        DataFrame with monthly completion rates for treated and matched controls
    """
    # Prepare the data
    program_col = f'{program}_this_month'
    prev_program_col = f'prev_{program}'

    # Filter to relevant months where the program was active
    active_months = monthly_df[monthly_df[program_col] == 1]['month'].unique()

    results = []

    for month in sorted(active_months):
        # Get treated individuals (received outreach this month)
        treated = monthly_df[(monthly_df['month'] == month) &
                            (monthly_df[program_col] == 1) &
                            (monthly_df[prev_program_col] == 0)].copy()

        if len(treated) == 0:
            continue

        # Get potential controls (no outreach in current or prior months)
        controls = monthly_df[(monthly_df['month'] == month) &
                            (monthly_df[program_col] == 0) &
                            (monthly_df[prev_program_col] == 0)].copy()

        if len(controls) == 0:
            continue

        # Prepare matching variables
        match_vars = ['prior_physical', 'office_visits']

        # Fit nearest neighbors model
        nn = NearestNeighbors(n_neighbors=n_matches, algorithm='ball_tree')
        nn.fit(controls[match_vars])

        # Find matches for each treated individual
        distances, indices = nn.kneighbors(treated[match_vars])

        # Calculate completion rates
        treated_completed = treated['completed'].mean()

        # Get matched controls
        matched_controls = controls.iloc[indices.flatten()]
        control_completed = matched_controls['completed'].mean()

        # Store results
        results.append({
            'program': program,
            'month': month,
            'treated_n': len(treated),
            'control_n': len(matched_controls),
            'treated_completion': treated_completed,
            'control_completion': control_completed,
            'lift': treated_completed - control_completed
        })

    return pd.DataFrame(results)

# Analyze all programs
programs = ['A', 'B', 'C']
all_results = []
for program in programs:
    program_results = rolling_matching_analysis(person_month_df, program)
    all_results.append(program_results)

results_df = pd.concat(all_results)

# Calculate average completion rates by program
summary_stats = results_df.groupby('program').agg({
    'treated_completion': 'mean',
    'control_completion': 'mean',
    'lift': 'mean',
    'treated_n': 'sum',
    'control_n': 'sum'
}).reset_index()

# Convert to percentages
summary_stats['treated_completion'] = summary_stats['treated_completion'] * 100
summary_stats['control_completion'] = summary_stats['control_completion'] * 100
summary_stats['lift'] = summary_stats['lift'] * 100


# Round the values in the summary_stats DataFrame to 1 decimal place
summary_stats = summary_stats.round(1)

# Save the rounded summary table to CSV
summary_stats.to_csv("physical_checkup_completion_rates.csv", index=False)

print("Summary table saved to 'physical_checkup_completion_rates.csv'.")
# Plot results
plt.figure(figsize=(10, 6))
sns.barplot(data=summary_stats, x='program', y='treated_completion',
            color='skyblue', label='Intervention Group')
sns.barplot(data=summary_stats, x='program', y='control_completion',
            color='lightcoral', label='Control Group')

for i, row in summary_stats.iterrows():
    plt.text(i, row['treated_completion'] + 1, f"{row['treated_completion']:.1f}%", ha='center')
    plt.text(i, row['control_completion'] - 1, f"{row['control_completion']:.1f}%", ha='center')

plt.title('Physical Checkup Completion Rates by Program')
plt.ylabel('Completion Rate (%)')
plt.xlabel('Program')
plt.ylim(0, 50)
plt.legend()
plt.tight_layout()

# 1. Save the figure first
plt.savefig("Physical_Checkup_Completion_Rates_By_Program.png", dpi=300)

# 2. Then show it
plt.show()

# 3. (Optional) Close the figure if you don't need it afterward
plt.close()

print("Bar chart figure saved as 'Physical_Checkup_Completion_Rates_By_Program.png'.")

# Plot monthly trends
# Plot monthly trends
plt.figure(figsize=(12, 6))

for program in programs:
    program_data = results_df[results_df['program'] == program]
    plt.plot(program_data['month'], program_data['treated_completion'] * 100,
             label=f'{program} - Intervention', marker='o')
    plt.plot(program_data['month'], program_data['control_completion'] * 100,
             label=f'{program} - Control', linestyle='--', marker='x')

plt.title('Monthly Physical Checkup Completion Rates')
plt.ylabel('Completion Rate (%)')
plt.xlabel('Month')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid(True)
plt.tight_layout()

# 1) Save the figure BEFORE showing it:
plt.savefig("Monthly_Physical_Checkup_Completion_Rates.png", dpi=300)

# 2) Then show the plot (optional if you want to see it interactively)
plt.show()

# 3) Close the figure
plt.close()

print("Line plot figure saved as 'Monthly_Physical_Checkup_Completion_Rates.png'.")